import { TypedEventEmitter } from '@livekit/typed-emitter';
import { g as TextStreamHandler, f as ByteStreamHandler } from '../src/stream_reader-DRyR29vo.ts';
import { E2EEManager, E2EEOptions } from '../src/e2ee.ts';
import { RemoteParticipant, LocalParticipant, Participant } from '../src/participant.ts';
import { DisconnectReason } from '../src/proto/participant_pb.ts';
import { RoomInfo, ConnectionQuality, DataPacketKind, ConnectionState, IceTransportType, ContinualGatheringPolicy, IceServer, RoomOptions as RoomOptions$1 } from '../src/proto/room_pb.ts';
import { LocalTrack, RemoteTrack } from '../src/track.ts';
import { LocalTrackPublication, RemoteTrackPublication, TrackPublication } from '../src/track_publication.ts';
import { ChatMessage } from '../src/types.ts';
import '../src/proto/e2ee_pb.ts';
import '@bufbuild/protobuf';
import 'node:fs';
import '../src/data_streams/stream_writer.ts';
import '../src/ffi_client.ts';
import '../src/napi/native.js';
import '../src/proto/ffi_pb.ts';
import '../src/proto/track_pb.ts';
import '../src/proto/stats_pb.ts';
import '../src/proto/handle_pb.ts';
import '../src/proto/video_frame_pb.ts';
import '../src/proto/audio_frame_pb.ts';
import '../src/proto/rpc_pb.ts';
import '../src/proto/track_publication_pb.ts';
import '../src/proto/data_stream_pb.ts';
import '../src/rpc.ts';
import '../src/transcription.ts';
import '../src/audio_source.ts';
import '../src/audio_frame.ts';
import '../src/video_source.ts';
import '../src/video_frame.ts';

interface RtcConfiguration {
    iceTransportType: IceTransportType;
    continualGatheringPolicy: ContinualGatheringPolicy;
    iceServers: IceServer[];
}
declare const defaultRtcConfiguration: RtcConfiguration;
interface RoomOptions {
    autoSubscribe: boolean;
    dynacast: boolean;
    e2ee?: E2EEOptions;
    rtcConfig?: RtcConfiguration;
}
declare const defaultRoomOptions: RoomOptions$1;
declare const Room_base: new () => TypedEventEmitter<RoomCallbacks>;
declare class Room extends Room_base {
    private info?;
    private ffiHandle?;
    private byteStreamControllers;
    private textStreamControllers;
    private byteStreamHandlers;
    private textStreamHandlers;
    private preConnectEvents;
    e2eeManager?: E2EEManager;
    connectionState: ConnectionState;
    remoteParticipants: Map<string, RemoteParticipant>;
    localParticipant?: LocalParticipant;
    constructor();
    get name(): string | undefined;
    get metadata(): string | undefined;
    get isConnected(): boolean;
    /**
     * Gets the room's server ID. This ID is assigned by the LiveKit server
     * and is unique for each room session.
     * SID is assigned asynchronously after connection.
     * @returns Promise that resolves to the room's server ID, or empty string if not connected
     */
    getSid(): Promise<string>;
    get numParticipants(): number;
    get numPublishers(): number;
    get creationTime(): Date;
    get isRecording(): boolean;
    /**
     * The time in seconds after which a room will be closed after the last
     * participant has disconnected.
     */
    get departureTimeout(): number;
    /**
     * The time in seconds after which an empty room will be automatically closed.
     */
    get emptyTimeout(): number;
    /**
     * Connects to a LiveKit room using the provided URL and access token.
     * @param url The WebSocket URL of the LiveKit server
     * @param token A valid LiveKit access token for authentication
     * @param opts Optional room configuration options
     * @throws ConnectError if connection fails
     */
    connect(url: string, token: string, opts?: RoomOptions): Promise<void>;
    /**
     * Disconnects from the room and cleans up all resources.
     * This will stop all tracks and close the connection.
     */
    disconnect(): Promise<void>;
    /**
     * Registers a handler for incoming text data streams on a specific topic.
     * Text streams are used for receiving structured text data from other participants.
     * @param topic The topic to listen for text streams on
     * @param callback Function to handle incoming text stream data
     * @throws Error if a handler for this topic is already registered
     */
    registerTextStreamHandler(topic: string, callback: TextStreamHandler): void;
    unregisterTextStreamHandler(topic: string): void;
    /**
     * Registers a handler for incoming byte data streams on a specific topic.
     * Byte streams are used for receiving binary data like files from other participants.
     * @param topic The topic to listen for byte streams on
     * @param callback Function to handle incoming byte stream data
     * @throws Error if a handler for this topic is already registered
     */
    registerByteStreamHandler(topic: string, callback: ByteStreamHandler): void;
    unregisterByteStreamHandler(topic: string): void;
    private onFfiEvent;
    private processFfiEvent;
    private retrieveParticipantByIdentity;
    private requireParticipantByIdentity;
    private requireRemoteParticipant;
    private requirePublicationOfParticipant;
    private requirePublicationOfRemoteParticipant;
    private createRemoteParticipant;
    private handleStreamHeader;
    private handleStreamChunk;
    private handleStreamTrailer;
}
declare class ConnectError extends Error {
    constructor(message: string);
}
type RoomCallbacks = {
    participantConnected: (participant: RemoteParticipant) => void;
    participantDisconnected: (participant: RemoteParticipant) => void;
    localTrackPublished: (publication: LocalTrackPublication, participant: LocalParticipant) => void;
    localTrackUnpublished: (publication: LocalTrackPublication, participant: LocalParticipant) => void;
    localTrackSubscribed: (track: LocalTrack) => void;
    trackPublished: (publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackUnpublished: (publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackSubscribed: (track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackUnsubscribed: (track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackSubscriptionFailed: (trackSid: string, participant: RemoteParticipant, reason?: string) => void;
    trackMuted: (publication: TrackPublication, participant: Participant) => void;
    trackUnmuted: (publication: TrackPublication, participant: Participant) => void;
    activeSpeakersChanged: (speakers: Participant[]) => void;
    roomMetadataChanged: (metadata: string) => void;
    roomInfoUpdated: (info: RoomInfo) => void;
    participantMetadataChanged: (metadata: string | undefined, participant: Participant) => void;
    participantNameChanged: (name: string, participant: Participant) => void;
    participantAttributesChanged: (changedAttributes: Record<string, string>, participant: Participant) => void;
    connectionQualityChanged: (quality: ConnectionQuality, participant: Participant) => void;
    dataReceived: (payload: Uint8Array, participant?: RemoteParticipant, kind?: DataPacketKind, topic?: string) => void;
    chatMessage: (message: ChatMessage, participant?: Participant) => void;
    dtmfReceived: (code: number, digit: string, participant: RemoteParticipant) => void;
    encryptionError: (error: Error) => void;
    connectionStateChanged: (state: ConnectionState) => void;
    connected: () => void;
    disconnected: (reason: DisconnectReason) => void;
    reconnecting: () => void;
    reconnected: () => void;
    roomSidChanged: (sid: string) => void;
    roomUpdated: () => void;
    moved: () => void;
};
declare enum RoomEvent {
    ParticipantConnected = "participantConnected",
    ParticipantDisconnected = "participantDisconnected",
    LocalTrackPublished = "localTrackPublished",
    LocalTrackUnpublished = "localTrackUnpublished",
    LocalTrackSubscribed = "localTrackSubscribed",
    TrackPublished = "trackPublished",
    TrackUnpublished = "trackUnpublished",
    TrackSubscribed = "trackSubscribed",
    TrackUnsubscribed = "trackUnsubscribed",
    TrackSubscriptionFailed = "trackSubscriptionFailed",
    TrackMuted = "trackMuted",
    TrackUnmuted = "trackUnmuted",
    ActiveSpeakersChanged = "activeSpeakersChanged",
    RoomMetadataChanged = "roomMetadataChanged",
    RoomSidChanged = "roomSidChanged",
    ParticipantMetadataChanged = "participantMetadataChanged",
    ParticipantNameChanged = "participantNameChanged",
    ParticipantAttributesChanged = "participantAttributesChanged",
    ConnectionQualityChanged = "connectionQualityChanged",
    DataReceived = "dataReceived",
    ChatMessage = "chatMessage",
    DtmfReceived = "dtmfReceived",
    EncryptionError = "encryptionError",
    ConnectionStateChanged = "connectionStateChanged",
    Connected = "connected",
    Disconnected = "disconnected",
    Reconnecting = "reconnecting",
    Reconnected = "reconnected",
    RoomUpdated = "roomUpdated",
    Moved = "moved"
}

export { ConnectError, Room, type RoomCallbacks, RoomEvent, type RoomOptions, type RtcConfiguration, defaultRoomOptions, defaultRtcConfiguration };
